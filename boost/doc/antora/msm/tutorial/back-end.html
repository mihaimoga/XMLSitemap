<!DOCTYPE html>
<html lang="en">
  <head>
        <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Back-end :: Boost Libraries Documentation</title>
  <link rel="canonical" href="https://antora.cppalliance.org/master/lib/doc/msm/tutorial/back-end.html">
    <link rel="prev" href="euml-front-end.html">
    <link rel="next" href="backmp11-back-end.html">
  <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../../_/css/boostlook.css">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/tabs.css">
    <script>var uiRootPath = '../../_'</script>
<link rel="icon" href="../../_/img/favicons/favicon.ico" type="image/x-icon">
    <!-- Favicon configuration -->
    <link rel="apple-touch-icon" sizes="180x180" href="../../_/img/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../_/img/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../_/img/favicons/favicon-16x16.png">
    <link rel="manifest" href="../../_/img/favicons/site.webmanifest">
    <link rel="shortcut icon" href="../../_/img/favicons/favicon.ico">
  </head>
  <body class="article toc2 toc-left">
    <div class="boostlook">
  <div id="header">
    <div id="toc" class="nav-container toc2" data-component="msm" data-version="">
  <aside class="nav">
    <button class="nav-close"></button>
    <div class="panels">
      <div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
      <h3 class="title"><a href="../index.html">Boost.MetaStateMachine</a></h3>
      <ul class="nav-list">
        <ul class="nav-list">
        <li class="" data-depth="1">
            <a class="nav-link" href="../index.html">Table of Contents</a>
        </li>
        <ul class="nav-list">
        <li class="" data-depth="2">
            <a class="nav-link" href="../preface.html">Preface</a>
        </li>
              <li class="" data-depth="2">
            <a class="nav-link" href="../founding-idea.html">Founding idea</a>
        </li>
              <li class="" data-depth="2">
            <a class="nav-link" href="../uml-short-guide.html">UML short guide</a>
        </li>
              <li class="" data-depth="2">
            <a class="nav-link" href="../tutorial.html">Tutorial</a>
        </li>
        <ul class="nav-list">
        <li class="" data-depth="3">
            <a class="nav-link" href="basic-front-end.html">Basic front-end</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="functor-front-end.html">Functor front-end</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="puml-front-end.html">PUML front-end (C++20, experimental)</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="euml-front-end.html">eUML front-end (deprecated)</a>
        </li>
              <li class=" is-current-page" data-depth="3">
            <a class="nav-link" href="back-end.html">Back-end</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="backmp11-back-end.html">Backmp11 back-end (C++17, experimental)</a>
        </li>
        </ul>
        <li class="" data-depth="2">
            <a class="nav-link" href="../performance-compilers.html">Performance / Compilers</a>
        </li>
              <li class="" data-depth="2">
            <a class="nav-link" href="../questions-answers-tips.html">Questions &amp; Answers, tips</a>
        </li>
              <li class="" data-depth="2">
            <a class="nav-link" href="../internals.html">Internals</a>
        </li>
              <li class="" data-depth="2">
            <a class="nav-link" href="../acknowledgements.html">Acknowledgements</a>
        </li>
              <li class="" data-depth="2">
            <a class="nav-link" href="../version-history.html">Version history</a>
        </li>
              <li class="" data-depth="2">
            <a class="nav-link" href="../reference.html">Reference</a>
        </li>
        <ul class="nav-list">
        <li class="" data-depth="3">
            <a class="nav-link" href="../reference/external-references-to-msm.html">External references to MSM</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="../reference/euml-operators-and-basic-helpers.html">eUML operators and basic helpers</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="../reference/functional-programming.html">Functional programming</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="../reference/common-headers.html">Common headers</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="../reference/back-end-headers.html">Back-end headers</a>
        </li>
              <li class="" data-depth="3">
            <a class="nav-link" href="../reference/front-end-headers.html">Front-end headers</a>
        </li>
        </ul>
  </ul>
  </ul>
  </ul>
  </nav>
</div>
    </div>
  </aside>
</div>
</div>
  <div id="content">
      <aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
    <article class="doc max-width-reset">
  <div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li>
      <a href="../index.html" aria-label="Home: Boost.MetaStateMachine">
        <svg xmlns="http://www.w3.org/2000/svg" width="1rem" height="1rem" viewBox="0 -960 960 960" fill="#000000" aria-hidden="true"><path d="M160-120v-480l320-240 320 240v480H560v-280H400v280H160Z"/></svg>
      </a>
    </li>
    <li><a href="../index.html">Table of Contents</a></li>
    <li><a href="../tutorial.html">Tutorial</a></li>
    <li><a href="back-end.html">Back-end</a></li>
  </ul>
</nav>
<div class="spirit-nav">
    <a accesskey="p" href="euml-front-end.html">
      <span class="material-symbols-outlined" title="Previous: eUML front-end (deprecated)">arrow_back</span>
    </a>
    <a accesskey="u" href="../tutorial.html">
      <span class="material-symbols-outlined" title="Up: Tutorial">arrow_upward</span>
    </a>
    <a accesskey="n" href="backmp11-back-end.html">
      <span class="material-symbols-outlined" title="Next: Backmp11 back-end (C++17, experimental)">arrow_forward</span>
    </a>
</div></div>
    <h1 class="page">Back-end</h1>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The back-end contains the library engine and defines the performance and functionality trade-offs. There are, at the moment, three back-ends:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>msm::back</code> is using C&#43;&#43;03</p>
</li>
<li>
<p><code>msm::back11</code> is using C&#43;&#43;11 and should be used by default if possible as it removes some pre-C&#43;&#43;11 limitations (mpl::vector of limited size)</p>
</li>
<li>
<p><code>msm::backmp11</code> is using C&#43;&#43;17 (it is still experimental at the moment and further described in a <a href="backmp11-back-end.html" class="xref page">separate page</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The currently available back-ends implement most of the functionality
defined by the UML 2.0 standard at very high runtime speed, in exchange
for longer compile-time. The runtime speed is due to a constant-time
double-dispatch and self-adapting capabilities allowing the framework to
adapt itself to the features used by a given concrete state machine. All
unneeded features either disable themselves or can be manually disabled.
See section 5.1 for a complete description of the run-to-completion
algorithm.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creation"><a class="anchor" href="#creation"></a>Creation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MSM being divided between front and back-end, one needs to first define
a front-end. Then, to create a real state machine, the back-end must be
declared:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>typedef msm::back11::state_machine&lt;my_front_end&gt; my_fsm;</pre>
</div>
</div>
<div class="paragraph">
<p>We now have a fully functional state machine type. The next sections
will describe what can be done with it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-start"><a class="anchor" href="#backend-start"></a>Starting and stopping a state machine</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>start()</code> method starts the state machine, meaning it will activate
the initial state, which means in turn that the initial state&#8217;s entry
behavior will be called. We need the start method because you do not
always want the entry behavior of the initial state to be called
immediately but only when your state machine is ready to process events.
A good example of this is when you use a state machine to write an
algorithm and each loop back to the initial state is an algorithm call.
Each call to start will make the algorithm run once. The
<a href="../_attachments/iPodSearch.cpp" class="xref attachment">iPodSearch</a> example uses this possibility.</p>
</div>
<div class="paragraph">
<p>The <code>stop()</code> method works the same way. It will cause the exit actions
of the currently active state(s) to be called.</p>
</div>
<div class="paragraph">
<p>Both methods are actually not an absolute need. Not calling them will
simply cause your first entry or your last exit action not to be called.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="event-dispatching"><a class="anchor" href="#event-dispatching"></a>Event dispatching</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main reason to exist for a state machine is to dispatch events. For
MSM, events are objects of a given event type. The object itself can
contain data, but the event type is what decides of the transition to be
taken. For MSM, if some_event is a given type (a simple struct for
example) and e1 and e2 concrete instances of some_event, e1 and e2 are
equivalent, from a transition perspective. Of course, e1 and e2 can have
different values and you can use them inside actions. Events are
dispatched as const reference, so actions cannot modify events for
obvious side-effect reasons. To dispatch an event of type some_event,
you can simply create one on the fly or instantiate if before
processing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>my_fsm fsm; fsm.process_event(some_event());
some_event e1; fsm.process_event(e1)</pre>
</div>
</div>
<div class="paragraph">
<p>Creating an event on the fly will be optimized by the compiler so the
performance will not degrade.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="active-states"><a class="anchor" href="#active-states"></a>Active state(s)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The backend also offers a way to know which state is active, though you
will normally only need this for debugging purposes. If what you need
simply is doing something with the active state, <code>internal transitions</code>
or <code>visitors</code> are a better alternative. If you need to know what state
is active, const int* current_state() will return an array of state ids.
Please refer to the <code>internals section</code> to know how state ids are
generated.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="upper-state-machine"><a class="anchor" href="#upper-state-machine"></a>Upper State Machine (<code>msm::back11</code> only)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The FSM template argument passed to functors or entry/exit actions is
the current state machine, which might not be what is wanted as the
upper state machine makes more sense. The back-end provides a
get_upper() function returning a pointer to the upper state machine,
which is usually what you want to call process_event on.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="back-end-serialization"><a class="anchor" href="#back-end-serialization"></a>Serialization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A common need is the ability to save a state machine and restore it at a
different time. MSM supports this feature for the basic and functor
front-ends, and in a more limited manner for eUML. MSM supports
boost::serialization out of the box (by offering a <code>serialize</code>
function). Actually, for basic serialization, you need not do much, a
MSM state machine is serializable almost like any other type. Without
any special work, you can make a state machine remember its state, for
example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>MyFsm fsm;
// write to archive
std::ofstream ofs("fsm.txt");
// save fsm to archive
{
    boost::archive::text_oarchive oa(ofs);
    // write class instance to archive
    oa &lt;&lt; fsm;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Loading back is very similar:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>MyFsm fsm;
{
    // create and open an archive for input
    std::ifstream ifs("fsm.txt");
    boost::archive::text_iarchive ia(ifs);
    // read class state from archive
    ia &gt;&gt; fsm;
}</pre>
</div>
</div>
<div class="paragraph">
<p>This will (de)serialize the state machine itself but not the concrete
states' data. This can be done on a per-state basis to reduce the amount
of typing necessary. To allow serialization of a concrete state, provide
a do_serialize typedef and implement the serialize function:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct Empty : public msm::front::state&lt;&gt;
{
    // we want Empty to be serialized. First provide the typedef
    typedef int do_serialize;
    // then implement serialize
    template&lt;class Archive&gt;
    void serialize(Archive &amp; ar, const unsigned int /* version */)
    {
        ar &amp; some_dummy_data;
    }
    Empty():some_dummy_data(0){}
    int some_dummy_data;
};</pre>
</div>
</div>
<div class="paragraph">
<p>You can also serialize data contained in the front-end class. Again, you
need to provide the typedef and implement serialize:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct player_ : public msm::front::state_machine_def&lt;player_&gt;
{
    //we might want to serialize some data contained by the front-end
    int front_end_data;
    player_():front_end_data(0){}
    // to achieve this, provide the typedef
    typedef int do_serialize;
    // and implement serialize
    template&lt;class Archive&gt;
    void serialize(Archive &amp; ar, const unsigned int )
    {
        ar &amp; front_end_data;
    }
...
};</pre>
</div>
</div>
<div class="paragraph">
<p>The saving of the back-end data (the current state(s)) is valid for all
front-ends, so a front-end written using eUML can be serialized.
However, to serialize a concrete state, the macros like
<code>BOOST_MSM_EUML_STATE</code> cannot be used, so the state will have to be
implemented by directly inheriting from <code>front::euml::euml_state</code>.</p>
</div>
<div class="paragraph">
<p>The only limitation is that the event queues cannot be serialized so
serializing must be done in a stable state, when no event is being
processed. You can serialize during event processing only if using no
queue (deferred or event queue).</p>
</div>
<div class="paragraph">
<p>This <a href="../_attachments/Serialize.cpp" class="xref attachment">example</a> shows a state machine which we
serialize after processing an event. The <code>Empty</code> state also has some
data to serialize.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-base-state"><a class="anchor" href="#backend-base-state"></a>Base state type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes, one needs to customize states to avoid repetition and provide
a common functionality, for example in the form of a virtual method. You
might also want to make your states polymorphic so that you can call
typeid on them for logging or debugging. It is also useful if you need a
visitor, like the next section will show. You will notice that all
front-ends offer the possibility of adding a base type. Note that all
states and state machines must have the same base state, so this could
reduce reuse. For example, using the basic front end, you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add the non-default base state in your msm::front::state&lt;&gt; definition,
as first template argument (except for interrupt_states for which it is
the second argument, the first one being the event ending the
interrupt), for example, my_base_state being your new base state for all
states in a given state machine:</p>
<div class="literalblock">
<div class="content">
<pre>struct Empty : public msm::front::state&lt;my_base_state&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Now, my_base_state is your new base state. If it has a virtual function,
your states become polymorphic. MSM also provides a default polymorphic
base type, <code>msm::front::polymorphic_state</code></p>
</div>
</li>
<li>
<p>Add the user-defined base state in the state machine frontend
definition, as a second template argument, for example:</p>
<div class="literalblock">
<div class="content">
<pre>struct player_ : public msm::front::state_machine&lt;player_,my_base_state&gt;</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also ask for a state with a given id (which you might have
gotten from current_state()) using
<code>const base_state* get_state_by_id(int id) const</code> where base_state is
the one you just defined. You can now do something polymorphically.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-visitor"><a class="anchor" href="#backend-visitor"></a>Visitor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In some cases, having a pointer-to-base of the currently active states
is not enough. You might want to call non-virtually a method of the
currently active states. It will not be said that MSM forces the virtual
keyword down your throat!</p>
</div>
<div class="paragraph">
<p>To achieve this goal, MSM provides its own variation of a visitor
pattern using the previously described user-defined state technique. If
you add to your user-defined base state an <code>accept_sig</code> typedef giving
the return value (unused for the moment) and parameters and provide an
accept method with this signature, calling visit_current_states will
cause accept to be called on the currently active states. Typically, you
will also want to provide an empty default accept in your base state in
order not to force all your states to implement accept. For example your
base state could be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct my_visitable_state
{
   // signature of the accept function
   typedef args&lt;void&gt; accept_sig;
   // we also want polymorphic states
   virtual ~my_visitable_state() {}
   // default implementation for states who do not need to be visited
   void accept() const {}
};</pre>
</div>
</div>
<div class="paragraph">
<p>This makes your states polymorphic and visitable. In this case, accept
is made const and takes no argument. It could also be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct SomeVisitor {…};
struct my_visitable_state
{
    // signature of the accept function
    typedef args&lt;void,SomeVisitor&amp;&gt; accept_sig;
    // we also want polymorphic states
    virtual ~my_visitable_state() {}
    // default implementation for states who do not need to be visited
    void accept(SomeVisitor&amp;) const {}
};</pre>
</div>
</div>
<div class="paragraph">
<p>And now, <code>accept</code> will take one argument (it could also be non-const).
By default, <code>accept</code> takes up to 2 arguments. To get more, set #define
BOOST_MSM_VISITOR_ARG_SIZE to another value before including
state_machine.hpp. For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#define BOOST_MSM_VISITOR_ARG_SIZE 3
#include &lt;boost/msm/back/state_machine.hpp&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Note that accept will be called on ALL active states <em>and also
automatically on sub-states of a submachine</em>.</p>
</div>
<div class="paragraph">
<p><em>Important warning</em>: The method visit_current_states takes its parameter
by value, so if the signature of the accept function is to contain a
parameter passed by reference, pass this parameter with a boost:ref/cref
to avoid undesired copies or slicing. So, for example, in the above
case, call:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SomeVisitor vis; sm.visit_current_states(boost::ref(vis));</pre>
</div>
</div>
<div class="paragraph">
<p>This <a href="../_attachments/SM-2Arg.cpp" class="xref attachment">example</a> uses a visiting function with 2
arguments.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="flags"><a class="anchor" href="#flags"></a>Flags</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Flags is a MSM-only concept, supported by all front-ends, which base
themselves on the functions:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>template &lt;class Flag&gt; bool is_flag_active()
template &lt;class Flag,class BinaryOp&gt; bool is_flag_active()</pre>
</div>
</div>
<div class="paragraph">
<p>These functions return true if the currently active state(s) support the
Flag property. The first variant ORs the result if there are several
orthogonal regions, the second one expects OR or AND, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>my_fsm.is_flag_active&lt;MyFlag&gt;()
my_fsm.is_flag_active&lt;MyFlag,my_fsm_type::Flag_OR&gt;()</pre>
</div>
</div>
<div class="paragraph">
<p>Please refer to the front-ends sections for usage examples.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-a-state"><a class="anchor" href="#getting-a-state"></a>Getting a state</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is sometimes necessary to have the client code get access to the
states' data. After all, the states are created once for good and hang
around as long as the state machine does, so why not use it? You simply
just need sometimes to get information about any state, even inactive
ones. An example is if you want to write a coverage tool and know how
many times a state was visited. To get a state, use the get_state method
giving the state name, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>player::Stopped* tempstate = p.get_state&lt;player::Stopped*&gt;();</pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="literalblock">
<div class="content">
<pre>player::Stopped&amp; tempstate2 = p.get_state&lt;player::Stopped&amp;&gt;();</pre>
</div>
</div>
<div class="paragraph">
<p>depending on your personal taste.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-fsm-constructor-args"><a class="anchor" href="#backend-fsm-constructor-args"></a>State machine constructor with arguments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You might want to define a state machine with a non-default constructor.
For example, you might want to write:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct player_ : public msm::front::state_machine_def&lt;player_&gt;
{
    player_(int some_value){…}
};</pre>
</div>
</div>
<div class="paragraph">
<p>This is possible, using the back-end as forwarding object:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>typedef msm::back11::state_machine&lt;player_ &gt; player; player p(3);</pre>
</div>
</div>
<div class="paragraph">
<p>The back-end will call the corresponding front-end constructor upon
creation.</p>
</div>
<div class="paragraph">
<p>You can pass arguments up to the value of the
BOOST_MSM_CONSTRUCTOR_ARG_SIZE macro (currently 5) arguments. Change
this value before including any header if you need to overwrite the
default.</p>
</div>
<div class="paragraph">
<p>You can also pass arguments by reference (or const-reference) using
boost::ref (or boost::cref):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>struct player_ : public msm::front::state_machine_def&lt;player_&gt;
{
   player_(SomeType&amp; t, int some_value){…}
};

typedef msm::back11::state_machine&lt;player_ &gt; player;
SomeType data;
player p(boost::ref(data),3);</pre>
</div>
</div>
<div class="paragraph">
<p>Normally, MSM default-constructs all its states or submachines. There
are however cases where you might not want this. An example is when you
use a state machine as submachine, and this submachine used the above
defined constructors. You can add as first argument of the state machine
constructor an expression where existing states are passed and copied:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>player p( back::states_ &lt;&lt; state_1 &lt;&lt; ... &lt;&lt; state_n , boost::ref(data),3);</pre>
</div>
</div>
<div class="paragraph">
<p>Where state_1..n are instances of some or all of the states of the state
machine. Submachines being state machines, this can recurse, for
example, if Playing is a submachine containing a state Song1 having
itself a constructor where some data is passed:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>player p( back::states_ &lt;&lt; Playing(back::states_ &lt;&lt; Song1(some_Song1_data)) ,
          boost::ref(data),3);</pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to replace a given state by a new instance at any
time using <code>set_states()</code> and the same syntax, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>p.set_states( back::states_ &lt;&lt; state_1 &lt;&lt; ... &lt;&lt; state_n );</pre>
</div>
</div>
<div class="paragraph">
<p>An <a href="../_attachments/Constructor.cpp" class="xref attachment">example</a> making intensive use of this
capability is provided.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-tradeof-rt-ct"><a class="anchor" href="#backend-tradeof-rt-ct"></a>Trading run-time speed for better compile-time / multi-TU compilation (<code>msm::back</code> only)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MSM is optimized for run-time speed at the cost of longer compile-time.
This can become a problem with older compilers and big state machines,
especially if you don&#8217;t really care about run-time speed that much and
would be satisfied by a performance roughly the same as most state
machine libraries. MSM offers a back-end policy to help there. But
before you try it, if you are using a VC compiler, deactivate the /Gm
compiler option (default for debug builds). This option can cause builds
to be 3 times longer&#8230;&#8203; If the compile-time still is a problem, read
further. MSM offers a policy which will speed up compiling in two main
cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>many transition conflicts</p>
</li>
<li>
<p>submachines</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The back-end <code>msm::back11::state_machine</code> has a policy argument (first
is the front-end, then the history policy) defaulting to
<code>favor_runtime_speed</code>. To switch to <code>favor_compile_time</code>, which is
declared in <code>&lt;msm/back/favor_compile_time.hpp&gt;</code>, you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>switch the policy to <code>favor_compile_time</code> for the main state machine
(and possibly submachines)</p>
</li>
<li>
<p>move the submachine declarations into their own header which includes
<code>&lt;msm/back/favor_compile_time.hpp&gt;</code></p>
</li>
<li>
<p>add for each submachine a cpp file including your header and calling a
macro, which generates helper code, for example:</p>
<div class="literalblock">
<div class="content">
<pre>#include "mysubmachine.hpp"
BOOST_MSM_BACK_GENERATE_PROCESS_EVENT(mysubmachine)</pre>
</div>
</div>
</li>
<li>
<p>configure your compiler for multi-core compilation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You will now compile your state machine on as many cores as you have
submachines, which will greatly speed up the compilation if you factor
your state machine into smaller submachines.</p>
</div>
<div class="paragraph">
<p>Independently, transition conflicts resolution will also be much faster.</p>
</div>
<div class="paragraph">
<p>This policy uses boost.any behind the hood, which means that we will
lose a feature which MSM offers with the default policy,
<a href="#event-hierarchy">event hierarchy</a>. The following example takes our
iPod example and speeds up compile-time by using this technique. We
have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../_attachments/iPod_distributed/iPod.cpp" class="xref attachment">our main state machine and
main function</a></p>
</li>
<li>
<p><a href="../_attachments/iPod_distributed/PlayingMode.hpp" class="xref attachment">PlayingMode moved to a
separate header</a></p>
</li>
<li>
<p><a href="../_attachments/iPod_distributed/PlayingMode.cpp" class="xref attachment">a cpp for PlayingMode</a></p>
</li>
<li>
<p><a href="../_attachments/iPod_distributed/MenuMode.hpp" class="xref attachment">MenuMode moved to a
separate header</a></p>
</li>
<li>
<p><a href="../_attachments/iPod_distributed/MenuMode.cpp" class="xref attachment">a cpp for MenuMode</a></p>
</li>
<li>
<p><a href="../_attachments/iPod_distributed/Events.hpp" class="xref attachment">events move to a separate
header as all machines use it</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-compile-time-analysis"><a class="anchor" href="#backend-compile-time-analysis"></a>Compile-time state machine analysis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A MSM state machine being a metaprogram, it is only logical that
checking for the validity of a concrete state machine happens
compile-time. To this aim, using the compile-time graph library
<a href="http://www.dynagraph.org/mpl_graph/">mpl_graph</a> (delivered at the moment
with MSM) from Gordon Woodhull, MSM provides several compile-time
checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Check that orthogonal regions are truly orthogonal.</p>
</li>
<li>
<p>Check that all states are either reachable from the initial states or
are explicit entries / pseudo-entry states.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To make use of this feature, the back-end provides a policy (default is
no analysis), <code>msm::back::mpl_graph_fsm_check</code>. For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> typedef msm::back11::state_machine&lt; player_,msm::back::mpl_graph_fsm_check&gt; player;</pre>
</div>
</div>
<div class="paragraph">
<p>As MSM is now using Boost.Parameter to declare policies, the policy
choice can be made at any position after the front-end type (in this
case <code>player_</code>).</p>
</div>
<div class="paragraph">
<p>In case an error is detected, a compile-time assertion is provoked.</p>
</div>
<div class="paragraph">
<p>This feature is not enabled by default because it has a non-neglectable
compile-time cost. The algorithm is linear if no explicit or pseudo
entry states are found in the state machine, unfortunately still
O(number of states * number of entry states) otherwise. This will be
improved in future versions of MSM.</p>
</div>
<div class="paragraph">
<p>The same algorithm is also used in case you want to omit providing the
region index in the <code>explicit entry / pseudo entry state</code> declaration.</p>
</div>
<div class="paragraph">
<p>The author&#8217;s advice is to enable the checks after any state machine
structure change and disable it again after sucessful analysis.</p>
</div>
<div class="paragraph">
<p>The <a href="../_attachments/TestErrorOrthogonality.cpp" class="xref attachment">following example</a> provokes
an assertion if one of the first two lines of the transition table is
used.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-enqueueing"><a class="anchor" href="#backend-enqueueing"></a>Enqueueing events for later processing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Calling <code>process_event(Event const&amp;)</code> will immediately process the event
with run-to-completion semantics. You can also enqueue the events and
delay their processing by calling <code>enqueue_event(Event const&amp;)</code> instead.
Calling <code>execute_queued_events()</code> will then process all enqueued events
(in FIFO order). Calling <code>execute_single_queued_event()</code> will execute
the oldest enqueued event.</p>
</div>
<div class="paragraph">
<p>You can query the queue size by calling <code>get_message_queue_size()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-queues"><a class="anchor" href="#backend-queues"></a>Customizing the message queues</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MSM uses by default a std::deque for its queues (one message queue for
events generated during run-to-completion or with <code>enqueue_event</code>, one
for deferred events). Unfortunately, on some STL implementations, it is
a very expensive container in size and copying time. Should this be a
problem, MSM offers an alternative based on boost::circular_buffer. The
policy is msm::back::queue_container_circular. To use it, you need to
provide it to the back-end definition:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> typedef msm::back11::state_machine&lt; player_,msm::back::queue_container_circular&gt; player;</pre>
</div>
</div>
<div class="paragraph">
<p>You can access the queues with get_message_queue and get_deferred_queue,
both returning a reference or a const reference to the queues
themselves. Boost::circular_buffer is outside of the scope of this
documentation. What you will however need to define is the queue
capacity (initially is 0) to what you think your queue will at most
grow, for example (size 1 is common):</p>
</div>
<div class="literalblock">
<div class="content">
<pre> fsm.get_message_queue().set_capacity(1);</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-boost-parameter"><a class="anchor" href="#backend-boost-parameter"></a>Policy definition with Boost.Parameter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MSM uses Boost.Parameter to allow easier definition of
back11::state_machine&lt;&gt; policy arguments (all except the front-end).
This allows you to define policy arguments (history, compile-time /
run-time, state machine analysis, container for the queues) at any
position, in any number. For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> typedef msm::back11::state_machine&lt; player_,msm::back::mpl_graph_fsm_check&gt; player;
 typedef msm::back11::state_machine&lt; player_,msm::back::AlwaysHistory&gt; player;
 typedef msm::back11::state_machine&lt; player_,msm::back::mpl_graph_fsm_check,msm::back::AlwaysHistory&gt; player;
 typedef msm::back11::state_machine&lt; player_,msm::back::AlwaysHistory,msm::back::mpl_graph_fsm_check&gt; player;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backend-state-switch"><a class="anchor" href="#backend-state-switch"></a>Choosing when to switch active states</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The UML Standard is silent about a very important question: when a
transition fires, at which exact point is the target state the new
active state of a state machine? At the end of the transition? After the
source state has been left? What if an exception is thrown? The Standard
considers that run-to-completion means a transition completes in almost
no time. But even this can be in some conditions a very very long time.
Consider the following example. We have a state machine representing a
network connection. We can be <code>Connected</code> and <code>Disconnected</code>. When we
move from one state to another, we send a (Boost) Signal to another
entity. By default, MSM makes the target state as the new state after
the transition is completed. We want to send a signal based on a flag
is_connected which is true when in state Connected.</p>
</div>
<div class="paragraph">
<p>We are in state <code>Disconnected</code> and receive an event <code>connect</code>. The
transition action will ask the state machine
<code>is_flag_active&lt;is_connected&gt;</code> and will get&#8230;&#8203; false because we are
still in <code>Disconnected</code>. Hmm, what to do? We could queue the action and
execute it later, but it means an extra queue, more work and higher
run-time.</p>
</div>
<div class="paragraph">
<p>MSM provides the possibility (in form of a policy) for a front-end to
decide when the target state becomes active. It can be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>before the transition fires, if the guard will allow the transition to
fire: <code>active_state_switch_before_transition</code></p>
</li>
<li>
<p>after calling the exit action of the source state:
<code>active_state_switch_after_exit</code></p>
</li>
<li>
<p>after the transition action is executed:
<code>active_state_switch_after_transition_action</code></p>
</li>
<li>
<p>after the entry action of the target state is executed (default):
<code>active_state_switch_after_entry</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The problem and the solution is shown for the
<a href="../_attachments/ActiveStateSetBeforeTransition.cpp" class="xref attachment">functor-front-end</a> and
<a href="../_attachments/ActivateStateBeforeTransitionEuml.cpp" class="xref attachment">eUML</a>. Removing
<code>active_state_switch_before_transition</code> will show the default state.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_known_limitations"><a class="anchor" href="#_known_limitations"></a>Known limitations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Any currently known issues and limitations with the <code>back</code> and <code>back11</code> back-ends are described below.</p>
</div>
<div class="sect2">
<h3 id="_deferring_events_in_orthogonal_regions"><a class="anchor" href="#_deferring_events_in_orthogonal_regions"></a>Deferring events in orthogonal regions</h3>
<div class="paragraph">
<p>The event deferral logic requires deferred events to be dispatched for evaluation.
When a deferred event is dispatched to orthogonal regions, each region individually decides whether to consume or defer the event.
This can lead to scenarios where one region defers the event and the other one processes it,
causing infinite recursions because the event deferral logic needs to re-evaluate the deferred-and-processed event over and over.</p>
</div>
<div class="paragraph">
<p>According to the UML standard, in such a case the event should be deferred as long as one region decides to defer it.
This issue can be worked around by explicitly ensuring (for example with guards) that the event is exclusively <em>either</em> deferred <em>or</em> processed.</p>
</div>
</div>
</div>
</div>
  <div class="edit-this-page">
      <a href="https://github.com/boostorg/msm/edit/develop/doc/modules/ROOT/pages/tutorial/back-end.adoc">Edit this Page</a>
      </div>
      <nav class="pagination">
        <span class="prev"><a href="euml-front-end.html">eUML front-end (deprecated)</a></span>
        <span class="next"><a href="backmp11-back-end.html">Backmp11 back-end (C++17, experimental)</a></span>
    </nav>
</article>
</div>
  <div id="footer">
  <script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/tabs.js" data-sync-storage-key="preferred-tab"></script>
</div>
</div>
  </body>
</html>
