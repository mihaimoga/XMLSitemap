<?xml version="1.0" standalone="yes"?>
<library-reference id="reference"><title>Reference</title><header id="doxygen.reference.scope__exit_8hpp" name="boost/scope_exit.hpp">
<para>Scope exits allow to execute arbitrary code when the enclosing scope exits. </para><macro id="doxygen.reference.scope__exit_8hpp_1ae0a86562a607889be5c08af8ad6ead1b" name="BOOST_SCOPE_EXIT" kind="functionlike"><macro-parameter name="capture_list"/><purpose>This macro declares a scope exit. </purpose><description><para>The scope exit declaration schedules the execution of the scope exit body at the exit of the enclosing scope:</para><para><programlisting language="c++">{ // Some local scope.
    ...
    BOOST_SCOPE_EXIT(capture_list) {
        ... // Body code.
    } BOOST_SCOPE_EXIT_END
    ...
}
</programlisting></para><para>The enclosing scope must be local. If multiple scope exits are declared within the same enclosing scope, the scope exit bodies are executed in the reversed order of their declarations. Note how the end of the scope exit body must be marked by  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput>.</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>capture_list</computeroutput></emphasis></entry><entry>On compilers that support variadic macros (see also Boost.Config <computeroutput>BOOST_NO_CXX11_VARIADIC_MACROS</computeroutput>), the capture list syntax is defined by the following grammar: <programlisting language="c++">capture_list:
        void | capture_tuple | capture_sequence
capture_tuple:
        capture, capture, ...
capture_sequence:
        (capture) (capture) ...
capture:
        [&amp;]variable | this_
</programlisting> On compilers that do not support variadic macros, <computeroutput>capture_tuple</computeroutput> cannot be used: <programlisting language="c++">capture_list:
        void | capture_sequence
</programlisting> Furthermore, if  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS">BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS</macroname></computeroutput> is defined on C++11 compilers that support lambda functions (i.e., Boost.Config's <computeroutput>BOOST_NO_CXX11_LAMBDAS</computeroutput> is not defined) then a semicolon <computeroutput>;</computeroutput> can be used instead of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput> and <computeroutput>this</computeroutput> can be used instead of <computeroutput>this_</computeroutput>: <programlisting language="c++">capture:
        [&amp;]variable | this_ | this
</programlisting>(Lexical conventions: <computeroutput>token1 | token2</computeroutput> means either <computeroutput>token1</computeroutput> or <computeroutput>token2</computeroutput>; <computeroutput>[token]</computeroutput> means either <computeroutput>token</computeroutput> or nothing; <computeroutput>{expression}</computeroutput> means the tokens resulting from the expression.)  </entry></row>
</tbody></tgroup></informaltable>
</para><para>Note that on compilers that support variadic macros (most of moder compliers and all C++11 compilers), the capture list can be specified as a comma-separated list of tokens (this is the preferred syntax). However, on all compilers the same macro  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> also allows to specify the capture list as a Boost.Preprocessor sequence of tokens (for supporting compilers without variadic macros and for backward compatibility with older versions of this library).</para><para>The name <computeroutput>variable</computeroutput> of each captured variable must be a valid name in the enclosing scope and it must appear exactly once in the capture list. If a capture starts with the ampersand sign <computeroutput>&amp;</computeroutput>, the corresponding variable will be available by reference within the scope exit body; otherwise, a copy of the variable will be made at the point of the scope exit declaration and that copy will be available inside the scope exit body (in this case, the variable's type must be <computeroutput>CopyConstructible</computeroutput>).</para><para>From within a member function, the object <computeroutput>this</computeroutput> can be captured using the special name <computeroutput>this_</computeroutput> in both the capture list and the scope exit body (using <computeroutput>this</computeroutput> instead of <computeroutput>this_</computeroutput> in the scope exit body leads to undefined behaviour).</para><para>It is possible to capture no variable by specifying the capture list as <computeroutput>void</computeroutput> (regardless of variadic macro support).</para><para>Only variables listed in the capture list, static variables, <computeroutput>extern</computeroutput> variables, global variables, functions, and enumerations from the enclosing scope can be used inside the scope exit body.</para><para>On various GCC versions the special macro  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> must be used instead of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> within templates (to maximize portability, it is recommended to always use  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> within templates).</para><para>On C++11, it is possible capture all variables in scope without listing their names one-by-one using the macro  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput>.</para><para>In general, the special macro  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID">BOOST_SCOPE_EXIT_ID</macroname></computeroutput> must be used instead of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> when it is necessary to expand multiple scope exit declarations on the same line.</para><para><emphasis role="bold">Warning:</emphasis> The implementation executes the scope exit body within a destructor thus the scope exit body must never throw in order to comply with STL exception safety requirements.</para><para><emphasis role="bold">Note:</emphasis> The implementation uses Boost.Typeof to automatically deduce the types of the captured variables. In order to compile code in type-of emulation mode, all types must be properly registered with Boost.Typeof (see the  <link linkend="scope_exit.getting_started"> Getting Started</link> section).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="scope_exit.tutorial"> Tutorial</link> section,  <link linkend="scope_exit.getting_started"> Getting Started</link> section,  <link linkend="scope_exit.no_variadic_macros"> No Variadic Macros</link> section,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID">BOOST_SCOPE_EXIT_ID</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.scope__exit_8hpp_1ab46e489b869d28c3e3e091168d2b775f" name="BOOST_SCOPE_EXIT_TPL" kind="functionlike"><macro-parameter name="capture_list"/><purpose>This macro is a workaround for various versions of GCC to declare scope exits within templates. </purpose><description><para>Various versions of the GCC compiler do not compile  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> inside function templates. As a workaround,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> should be used instead of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> in these cases:</para><para><programlisting language="c++">{ // Some local scope.
    ...
    BOOST_SCOPE_EXIT_TPL(capture_list) {
        ... // Body code.
    } BOOST_SCOPE_EXIT_END
    ...
}
</programlisting></para><para>The syntax of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> is the exact same as the one of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> (see  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> for more information).</para><para>On C++11 compilers,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> is not needed because  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> always compiles on GCC versions that support C++11. However,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> is still provided on C++11 so to write code that is portable between C++03 and C++11 compilers. It is recommended to always use  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> within templates so to maximize portability.</para><para>In general, the special macro  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID_TPL">BOOST_SCOPE_EXIT_ID_TPL</macroname></computeroutput> must be used instead of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> when it is necessary to expand multiple scope exit declarations on the same line within templates.</para><para><emphasis role="bold">Note:</emphasis> The issue in compiling scope exit declarations that some GCC versions have is illustrated by the following code (see also <ulink url="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=37920">GCC bug 37920</ulink>): <programlisting language="c++">template&lt;class T&gt;
void f(T const&amp; x) {
    int i = 0;
    struct local {
        typedef __typeof__(i) typeof_i;
        typedef __typeof__(x) typeof_x;
    };
    typedef local::typeof_i i_type;
    typedef local::typeof_x x_type;
}

int main(void) { f(0); }
</programlisting> This can be fixed by adding <computeroutput>typename</computeroutput> in front of <computeroutput>local::typeof_i</computeroutput> and <computeroutput>local::typeof_x</computeroutput> (which is the approach followed by the implementation of the  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> macro).</para><para><emphasis role="bold">Note:</emphasis> Although  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> has the same suffix as <computeroutput>BOOST_TYPEOF_TPL</computeroutput>, it does not follow the Boost.Typeof convention.</para><para><emphasis role="bold">See:</emphasis>  <link linkend="scope_exit.tutorial"> Tutorial</link> section,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID_TPL">BOOST_SCOPE_EXIT_ID_TPL</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.scope__exit_8hpp_1a4ea19ded1642bf122790823b237c0446" name="BOOST_SCOPE_EXIT_ID" kind="functionlike"><macro-parameter name="id"/><macro-parameter name="capture_list"/><purpose>This macro allows to expand multiple scope exit declarations on the same line. </purpose><description><para>This macro is equivalent to  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> but it can be expanded multiple times on the same line if different identifiers <computeroutput>id</computeroutput> are provided for each expansion (see  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> for more information).</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>id</computeroutput></emphasis></entry><entry>A unique identifier token which can be concatenated by the preprocessor (<computeroutput><emphasis role="bold">LINE</emphasis></computeroutput>, <computeroutput>scope_exit_number_1_on_line_123</computeroutput>, a combination of alphanumeric tokens, etc).  </entry></row>
<row>
<entry><emphasis role="bold"><computeroutput>capture_list</computeroutput></emphasis></entry><entry>Same as the <computeroutput>capture_list</computeroutput> parameter of the  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> macro.  </entry></row>
</tbody></tgroup></informaltable>
</para><para><emphasis role="bold">Note:</emphasis> This macro can be useful when the scope exit macros are expanded within user-defined macros (because nested macros expand on the same line). On some compilers (e.g., MSVC which supports the non standard <computeroutput><emphasis role="bold">COUNTER</emphasis></computeroutput> macro) it might not be necessary to use this macro but the use of this macro is always necessary to ensure portability when expanding multiple scope exit declarations on the same line.</para><para><emphasis role="bold">See:</emphasis>  <link linkend="scope_exit.tutorial"> Tutorial</link> section,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END_ID">BOOST_SCOPE_EXIT_END_ID</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL_ID">BOOST_SCOPE_EXIT_ALL_ID</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID_TPL">BOOST_SCOPE_EXIT_ID_TPL</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.scope__exit_8hpp_1a8a07c11243049c4548f88abe1e5130b0" name="BOOST_SCOPE_EXIT_ID_TPL" kind="functionlike"><macro-parameter name="id"/><macro-parameter name="capture_list"/><purpose>This macro is required to expand multiple scope exit declarations on the same line within templates on various versions of GCC. </purpose><description><para>This macro is equivalent to  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> but it can be expanded multiple times on the same line if different identifiers <computeroutput>id</computeroutput> are provided for each expansion (see  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> for more information). As with  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput>, it is recommended to always use this macro when expanding scope exits multiple times on the same line within templates.</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>id</computeroutput></emphasis></entry><entry>A unique identifier token which can be concatenated by the preprocessor (<computeroutput><emphasis role="bold">LINE</emphasis></computeroutput>, <computeroutput>scope_exit_number_1_on_line_123</computeroutput>, a combination of alphanumeric tokens, etc).  </entry></row>
<row>
<entry><emphasis role="bold"><computeroutput>capture_list</computeroutput></emphasis></entry><entry>Same as the <computeroutput>capture_list</computeroutput> parameter of the  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> macro.  </entry></row>
</tbody></tgroup></informaltable>
</para><para><emphasis role="bold">Note:</emphasis> This macro can be useful when the scope exit macros are expanded within user-defined macros (because nested macros expand on the same line). On some compilers (e.g., MSVC which supports the non standard <computeroutput><emphasis role="bold">COUNTER</emphasis></computeroutput> macro) it might not be necessary to use this macro but the use of this macro is always necessary to ensure portability when expanding multiple scope exit declarations on the same line.</para><para><emphasis role="bold">See:</emphasis>  <link linkend="scope_exit.tutorial"> Tutorial</link> section,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END_ID">BOOST_SCOPE_EXIT_END_ID</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID">BOOST_SCOPE_EXIT_ID</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL_ID">BOOST_SCOPE_EXIT_ALL_ID</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.scope__exit_8hpp_1abe3e0c14285fc6303c6cd46884912608" name="BOOST_SCOPE_EXIT_ALL" kind="functionlike"><macro-parameter name="capture_list"/><purpose>This macro declares a scope exit that captures all variables in scope (C++11 only). </purpose><description><para>This macro accepts a capture list starting with either <computeroutput>&amp;</computeroutput> or <computeroutput>=</computeroutput> to capture all variables in scope by reference or value respectively (following the same syntax of C++11 lambdas). A part from that, this macro works like  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> (see  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> for more information):</para><para><programlisting language="c++">{ // Some local scope.
    ...
    BOOST_SCOPE_EXIT_ALL(capture_list) { // C++11 only.
        ... // Body code.
    }; // Use `;` instead of `BOOST_SCOPE_EXIT_END` (C++11 only).
    ...
}
</programlisting></para><para>Note how the end of the scope exit body declared by this macro must be marked by a semi-column <computeroutput>;</computeroutput> (and not by  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput>).</para><para><emphasis role="bold">Warning:</emphasis> This macro is only available on C++11 compilers (specifically, on C++11 compilers that do not define the Boost.Config <computeroutput>BOOST_NO_CXX11_LAMBDAS</computeroutput> macro). It is not defined on non-C++11 compilers so its use on non-C++11 compilers will generate a compiler error.</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>capture_list</computeroutput></emphasis></entry><entry>On compilers that support variadic macros (see also Boost.Config <computeroutput>BOOST_NO_CXX11_VARIADIC_MACROS</computeroutput>), the capture list syntax is defined by the following grammar: <programlisting language="c++">capture_list:
        capture_tuple | capture_sequence
capture_tuple:
        {&amp; | =} [, capture, capture, ...]
capture_sequence:
        {(&amp;) | (=)} [(capture) (capture) ...]
capture:
        [&amp;]variable | this_
</programlisting> On compilers that do not support variadic macros, <computeroutput>capture_tuple</computeroutput> cannot be used: <programlisting language="c++">capture_list:
        void | capture_sequence
</programlisting> Furthermore, on C++11 compilers that support the use of <computeroutput>typename</computeroutput> outside templates, also <computeroutput>this</computeroutput> can be used to capture the object at member function scope: <programlisting language="c++">capture:
        [&amp;]variable | this_ | this
</programlisting>(Lexical conventions: <computeroutput>token1 | token2</computeroutput> means either <computeroutput>token1</computeroutput> or <computeroutput>token2</computeroutput>; <computeroutput>[token]</computeroutput> means either <computeroutput>token</computeroutput> or nothing; <computeroutput>{expression}</computeroutput> means the token resulting from the expression.)  </entry></row>
</tbody></tgroup></informaltable>
</para><para>Note that on compilers with variadic macro support (which should be all C++11 compilers), the capture list can be specified as a comma-separated list. On all compilers, the same macro  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput> also allows to specify the capture list as a Boost.Preprocessor sequence.</para><para>The capture list must always contain at least the leading <computeroutput>&amp;</computeroutput> or <computeroutput>=</computeroutput> so it can never be <computeroutput>void</computeroutput> (<computeroutput><link linkend="doxygen.reference.scope__exit_8hpp_1ae0a86562a607889be5c08af8ad6ead1b">BOOST_SCOPE_EXIT(void)</link></computeroutput> should be used to program scope exits with an empty capture list).</para><para>In general, the special macro  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL_ID">BOOST_SCOPE_EXIT_ALL_ID</macroname></computeroutput> must be used instead of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput> when it is necessary to expand multiple scope exit declarations on the same line.</para><para><emphasis role="bold">Warning:</emphasis> This macro capture list follows the exact same syntax of C++11 lambda captures which is unfortunately different from the syntax of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> captures (unless programmers define the  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS">BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS</macroname></computeroutput> macro). For example, like C++11 lambda functions,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput> requires to capture data members by capturing the object <computeroutput>this</computeroutput> while  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> allows to capture data members directly and without capturing the object.</para><para><emphasis role="bold">Warning:</emphasis> The implementation executes the scope exit body within a destructor thus the scope exit body must never throw in order to comply with STL exception safety requirements.</para><para><emphasis role="bold">Note:</emphasis> This macro can always be used also within templates (so there is no need for a <computeroutput>BOOST_SCOPE_EXIT_ALL_TPL</computeroutput> macro).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="scope_exit.tutorial"> Tutorial</link> section,  <link linkend="scope_exit.no_variadic_macros"> No Variadic Macros</link> section,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL_ID">BOOST_SCOPE_EXIT_ALL_ID</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.scope__exit_8hpp_1abcb51e455c43fb3f66ec5d5ea165f85a" name="BOOST_SCOPE_EXIT_ALL_ID" kind="functionlike"><macro-parameter name="id"/><macro-parameter name="capture_list"/><purpose>This macro allows to expand on the same line multiple scope exits that capture all variables in scope (C++11 only). </purpose><description><para>This macro is equivalent to  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput> but it can be expanded multiple times on the same line if different identifiers <computeroutput>id</computeroutput> are provided for each expansion (see  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput> for more information). As with  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput>, this macro is only available on C++11 compilers (specifically, on C++11 compilers that do not define the Boost.Config <computeroutput>BOOST_NO_CXX11_LAMBDAS</computeroutput> macro).</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>id</computeroutput></emphasis></entry><entry>A unique identifier token which can be concatenated by the preprocessor (<computeroutput><emphasis role="bold">LINE</emphasis></computeroutput>, <computeroutput>scope_exit_number_1_on_line_123</computeroutput>, a combination of alphanumeric tokens, etc).  </entry></row>
<row>
<entry><emphasis role="bold"><computeroutput>capture_list</computeroutput></emphasis></entry><entry>Same as the <computeroutput>capture_list</computeroutput> parameter of the  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput> macro.  </entry></row>
</tbody></tgroup></informaltable>
</para><para><emphasis role="bold">Note:</emphasis> This macro can be useful when the scope exit macros are expanded within user-defined macros (because nested macros expand on the same line). On some compilers (e.g., MSVC which supports the non standard <computeroutput><emphasis role="bold">COUNTER</emphasis></computeroutput> macro) it might not be necessary to use this macro but the use of this macro is always necessary to ensure portability when expanding multiple scope exit declarations on the same line.</para><para><emphasis role="bold">See:</emphasis>  <link linkend="scope_exit.tutorial"> Tutorial</link> section,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID">BOOST_SCOPE_EXIT_ID</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.scope__exit_8hpp_1afc2c5bf6e868d7d8d703c64a984d38cd" name="BOOST_SCOPE_EXIT_END"><purpose>This macro marks the end of a scope exit body. </purpose><description><para>This macro must follow the closing curly bracket <computeroutput>}</computeroutput> that ends the body of either  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> or  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput>:</para><para><programlisting language="c++">{ // Some local scope.
    ...
    BOOST_SCOPE_EXIT(capture_list) {
        ... // Body code.
    } BOOST_SCOPE_EXIT_END
    ...
}
</programlisting></para><para>In general, the special macro  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END_ID">BOOST_SCOPE_EXIT_END_ID</macroname></computeroutput> must be used instead of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput> when it is necessary to expand multiple scope exit bodies on the same line.</para><para><emphasis role="bold">Note:</emphasis> If programmers define the  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS">BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS</macroname></computeroutput> macro on C++11 compilers, a semicolon <computeroutput>;</computeroutput> can be used instead of this macro. However, to maximize portability, it is recommended to always use  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput>.</para><para><emphasis role="bold">See:</emphasis>  <link linkend="scope_exit.tutorial"> Tutorial</link> section,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END_ID">BOOST_SCOPE_EXIT_END_ID</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.scope__exit_8hpp_1adda4fc0deb8b2c6083b7e893cb009ed4" name="BOOST_SCOPE_EXIT_END_ID" kind="functionlike"><macro-parameter name="id"/><purpose>This macro allows to terminate multiple scope exit bodies on the same line. </purpose><description><para>This macro is equivalent to  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput> but it can be expanded multiple times on the same line if different identifiers <computeroutput>id</computeroutput> are provided for each expansion (see  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput> for more information).</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>id</computeroutput></emphasis></entry><entry>A unique identifier token which can be concatenated by the preprocessor (<computeroutput><emphasis role="bold">LINE</emphasis></computeroutput>, <computeroutput>scope_exit_number_1_on_line_123</computeroutput>, a combination of alphanumeric tokens, etc).  </entry></row>
</tbody></tgroup></informaltable>
</para><para><emphasis role="bold">Note:</emphasis> This macro can be useful when the scope exit macros are expanded within user-defined macros (because macros all expand on the same line). On some compilers (e.g., MSVC which supports the non standard <computeroutput><emphasis role="bold">COUNTER</emphasis></computeroutput> macro) it might not be necessary to use this macro but the use of this macro is always necessary to ensure portability when expanding multiple scope exit macros on the same line (because this library can only portably use <computeroutput><emphasis role="bold">LINE</emphasis></computeroutput> to internally generate unique identifiers).</para><para><emphasis role="bold">See:</emphasis>  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID">BOOST_SCOPE_EXIT_ID</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ID_TPL">BOOST_SCOPE_EXIT_ID_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.scope__exit_8hpp_1a5f0a7005a4d789e0aa6459f35081844c" name="BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS"><purpose>Force to use C++11 lambda functions to implement scope exits. </purpose><description><para>If programmers define this configuration macro on a C++11 compiler for which the Boost.Config macro <computeroutput>BOOST_NO_CXX11_LAMBDAS</computeroutput> is not defined, the  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> and  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> macros will use C++11 lambda functions to declare scope exits. By default this macro is not defined.</para><para><emphasis role="bold">Warning:</emphasis> When scope exits are implemented using lambda functions, the syntax of the capture list follows the exact same syntax of C++11 lambda captures which is in general different from the legacy capture syntax of this library. For example, C++11 lambdas require to capture data members by capturing the object <computeroutput>this</computeroutput> while this library always allowed to capture data members directly. Therefore, when this configuration macro is defined,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput> and  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput> are no longer backward compatible (and this is why this macro is not defined by default).</para><para>A semicolon <computeroutput>;</computeroutput> can be used instead of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput> when this configuration macro is defined (but it is recommended to always use  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput> so to maximize portability).</para><para><emphasis role="bold">Note:</emphasis> This configuration macro does not control the definition of  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_ALL">BOOST_SCOPE_EXIT_ALL</macroname></computeroutput> which is always and automatically defined on compilers that support C++11 lambda functions.</para><para><emphasis role="bold">See:</emphasis>  <computeroutput><macroname alt="BOOST_SCOPE_EXIT">BOOST_SCOPE_EXIT</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_TPL">BOOST_SCOPE_EXIT_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_SCOPE_EXIT_END">BOOST_SCOPE_EXIT_END</macroname></computeroutput>. </para></description></macro>
</header>
</library-reference>