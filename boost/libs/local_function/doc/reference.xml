<?xml version="1.0" standalone="yes"?>
<library-reference id="reference"><title>Reference</title><header id="doxygen.reference.local__function_8hpp" name="boost/local_function.hpp">
<para>Local functions allow to program functions locally, within other functions, and directly within the scope where they are needed. </para><macro id="doxygen.reference.local__function_8hpp_1a908ef82352c37bf49bcefc3ad41125a5" name="BOOST_LOCAL_FUNCTION" kind="functionlike"><macro-parameter name="declarations"/><purpose>This macro is used to start a local function declaration. </purpose><description><para>This macro must be used within a declarative context, it must follow the local function result type, it must be followed by the local function body code, and then by the  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput> macro (see the  <link linkend="boost_localfunction.tutorial"> Tutorial</link> and  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> sections): <programlisting language="c++">{ // Some declarative context.
    ...
    result_type BOOST_LOCAL_FUNCTION(declarations) {
        ... // Body code.
    } BOOST_LOCAL_FUNCTION_NAME(qualified_name)
    ...
}
</programlisting></para><para>As usual, exceptions specifications can be optionally programmed just after the macro and before the body code block <computeroutput>{ ... }</computeroutput> (but the exception specifications will only apply to the body code and not to the library code automatically generated by the macro expansion, see the  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section).</para><para>Within templates, the special macros  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput> and  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME_TPL">BOOST_LOCAL_FUNCTION_NAME_TPL</macroname></computeroutput> must be used.</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>declarations</computeroutput></emphasis></entry><entry>On compilers that support variadic macros, the parameter declarations are defined by the following grammar: <programlisting language="c++">declarations:
        void | declaration_tuple | declaration_sequence
declaration_tuple:
        declaration, declaration, ...
declaration_sequence:
        (declaration) (declaration) ...
declaration:
        bound_variable | parameter | default_value | result_type
bound_variable:
        [const] bind [(variable_type)] [&amp;] variable_name
parameter:
        [auto | register] parameter_type parameter_name
default_value:
        default parameter_default_value
result_type:
        return function_result_type
</programlisting> On compilers that do not support variadic macros, <computeroutput>declaration_tuple</computeroutput> cannot be used: <programlisting language="c++">declarations:
        void | declaration_sequence
</programlisting>(Lexical conventions: <computeroutput>token1 | token2</computeroutput> means either <computeroutput>token1</computeroutput> or <computeroutput>token2</computeroutput>; <computeroutput>[token]</computeroutput> means either <computeroutput>token</computeroutput> or nothing; <computeroutput>{expression}</computeroutput> means the token resulting from the expression.)  </entry></row>
</tbody></tgroup></informaltable>
</para><para>Note that on compilers that support variadic macros, commas can be used to separate the declarations resembling more closely the usual C++ function declaration syntax (this is the preferred syntax). However, for portability, on all C++ compilers (with and without variadic macros) the same library macros also accept parameter declarations specified as a Boost.Preprocessor sequence separated by round parenthesis <computeroutput>()</computeroutput>.</para><para>When binding the object <computeroutput>this</computeroutput>, the special symbol <computeroutput>this_</computeroutput> needs to be used instead of <computeroutput>this</computeroutput> as the name of the variable to bind and also within the local function body to access the object. (Mistakenly using <computeroutput>this</computeroutput> instead of <computeroutput>this_</computeroutput> might not always result in a compiler error and will in general result in undefined behaviour.)</para><para>The result type must either be specified just before the macro or within the macro declarations prefixed by <computeroutput>return</computeroutput> (but not in both places).</para><para>Within the local function body it possible to access the result type using <computeroutput>result_type</computeroutput>, the type of the first parameter using <computeroutput>arg1_type</computeroutput>, the type of the second parameter using <computeroutput>arg2_type</computeroutput>, etc. The bound variable types can be accessed using  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TYPEOF">BOOST_LOCAL_FUNCTION_TYPEOF</macroname></computeroutput>.</para><para>This macro cannot be portably expanded multiple times on the same line. In these cases, use the  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_ID">BOOST_LOCAL_FUNCTION_ID</macroname></computeroutput> macro instead.</para><para>The maximum number of local function parameters (excluding bound variables) is specified by the configuration macro  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX">BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX</macroname></computeroutput>. The maximum number of bound variables is specified by the configuration macro  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX">BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX</macroname></computeroutput>. The configuration macro  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS">BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS</macroname></computeroutput> can be used to force optimizations that reduce the local function call run-time overhead.</para><para><emphasis role="bold">Note:</emphasis> Local functions are functors so they can be assigned to other functors like <computeroutput>boost::function</computeroutput> (see Boost.Function).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.tutorial"> Tutorial</link> section,  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME_TPL">BOOST_LOCAL_FUNCTION_NAME_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TYPEOF">BOOST_LOCAL_FUNCTION_TYPEOF</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_ID">BOOST_LOCAL_FUNCTION_ID</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX">BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX">BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS">BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.local__function_8hpp_1a7bedf23d73b025538b2a2c33b7e46643" name="BOOST_LOCAL_FUNCTION_TPL" kind="functionlike"><macro-parameter name="declarations"/><purpose>This macro is used to start a local function declaration within templates. </purpose><description><para>This macro must be used instead of  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput> when declaring a local function within a template. A part from that, this macro has the exact same syntax a  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput> (see  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput> for more information): <programlisting language="c++">{ // Some declarative context within a template.
    ...
    result_type BOOST_LOCAL_FUNCTION_TPL(declarations) {
        ... // Body code.
    } BOOST_LOCAL_FUNCTION_NAME_TPL(qualified_name)
    ...
}
</programlisting></para><para>Note that  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME_TPL">BOOST_LOCAL_FUNCTION_NAME_TPL</macroname></computeroutput> must be used with this macro instead of  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput>.</para><para>This macro cannot be portably expanded multiple times on the same line. In these cases, use the  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_ID_TPL">BOOST_LOCAL_FUNCTION_ID_TPL</macroname></computeroutput> macro instead.</para><para><emphasis role="bold">Note:</emphasis> C++03 does not allow to use <computeroutput>typename</computeroutput> outside templates. This library internally manipulates types, these operations require <computeroutput>typename</computeroutput> but only within templates. This macro is used to indicate to the library when the enclosing scope is a template so the library can correctly use <computeroutput>typename</computeroutput>.</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.tutorial"> Tutorial</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_ID_TPL">BOOST_LOCAL_FUNCTION_ID_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME_TPL">BOOST_LOCAL_FUNCTION_NAME_TPL</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.local__function_8hpp_1a045a12bb42e7fa6ebc772e58c53fb862" name="BOOST_LOCAL_FUNCTION_ID" kind="functionlike"><macro-parameter name="id"/><macro-parameter name="declarations"/><purpose>This macro allows to declare multiple local functions on the same line. </purpose><description><para>This macro is equivalent to  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput> but it can be expanded multiple times on the same line if different identifiers <computeroutput>id</computeroutput> are provided for each expansion (see the  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section).</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>id</computeroutput></emphasis></entry><entry>A unique identifier token which can be concatenated by the preprocessor (<computeroutput><emphasis role="bold">LINE</emphasis></computeroutput>, <computeroutput>local_function_number_1_on_line_123</computeroutput>, etc).  </entry></row>
<row>
<entry><emphasis role="bold"><computeroutput>declarations</computeroutput></emphasis></entry><entry>Same as the <computeroutput>declarations</computeroutput> parameter of the  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput> macro.  </entry></row>
</tbody></tgroup></informaltable>
</para><para>The  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput> macro should be used to end each one of the multiple local function declarations as usual (and it will specify a unique name for each local function).</para><para>Within templates, the special macros  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_ID_TPL">BOOST_LOCAL_FUNCTION_ID_TPL</macroname></computeroutput> must be used.</para><para><emphasis role="bold">Note:</emphasis> This macro can be useful when the local function macros are expanded within user-defined macros (because macros all expand on the same line). On some compilers (e.g., MSVC which supports the non-standard <computeroutput><emphasis role="bold">COUNTER</emphasis></computeroutput> macro) it might not be necessary to use this macro but the use of this macro when expanding multiple local function macros on the same line is always necessary to ensure portability (this is because this library can only portably use <computeroutput><emphasis role="bold">LINE</emphasis></computeroutput> to internally generate unique identifiers).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_ID_TPL">BOOST_LOCAL_FUNCTION_ID_TPL</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.local__function_8hpp_1a324ca4fae959d468dc322cfdccc0f37f" name="BOOST_LOCAL_FUNCTION_ID_TPL" kind="functionlike"><macro-parameter name="id"/><macro-parameter name="declarations"/><purpose>This macro allows to declare multiple local functions on the same line within templates. </purpose><description><para>This macro must be used instead of  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput> when declaring multiple local functions on the same line within a template. A part from that, this macro has the exact same syntax as  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput> (see  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput> for more information).</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>id</computeroutput></emphasis></entry><entry>A unique identifier token which can be concatenated by the preprocessor (<computeroutput><emphasis role="bold">LINE</emphasis></computeroutput>, <computeroutput>local_function_number_1_on_line_123</computeroutput>, etc).  </entry></row>
<row>
<entry><emphasis role="bold"><computeroutput>declarations</computeroutput></emphasis></entry><entry>Same as the <computeroutput>declarations</computeroutput> parameter of the  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput> macro.  </entry></row>
</tbody></tgroup></informaltable>
</para><para>The  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput> macro should be used to end each one of the multiple local function declarations as usual (and it will specify a unique name for each local function).</para><para>Outside template, the macro  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_ID">BOOST_LOCAL_FUNCTION_ID</macroname></computeroutput> should be used to declare multiple local functions on the same line.</para><para><emphasis role="bold">Note:</emphasis> This macro can be useful when the local function macros are expanded within user-defined macros (because macros all expand on the same line). On some compilers (e.g., MSVC which supports the non-standard <computeroutput><emphasis role="bold">COUNTER</emphasis></computeroutput> macro) it might not be necessary to use this macro but the use of this macro when expanding multiple local function macros on the same line is always necessary to ensure portability (this is because this library can only portably use <computeroutput><emphasis role="bold">LINE</emphasis></computeroutput> to internally generate unique identifiers).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_ID">BOOST_LOCAL_FUNCTION_ID</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.local__function_8hpp_1aaf721b5c898c82619d1fde46712d2cbf" name="BOOST_LOCAL_FUNCTION_NAME" kind="functionlike"><macro-parameter name="qualified_name"/><purpose>This macro is used to end a local function declaration specifying its name. </purpose><description><para>This macro must follow the local function body code block <computeroutput>{ ... }</computeroutput>: <programlisting language="c++">{ // Some declarative context.
    ...
    result_type BOOST_LOCAL_FUNCTION(declarations) {
        ... // Body code.
    } BOOST_LOCAL_FUNCTION_NAME(qualified_name)
    ...
}
</programlisting></para><para>Within templates, the special macros  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput> and  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME_TPL">BOOST_LOCAL_FUNCTION_NAME_TPL</macroname></computeroutput> must be used.</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>qualified_name</computeroutput></emphasis></entry><entry>The name of the local function optionally qualified as follow: <programlisting language="c++">name:
        [inline] [recursive] local_function_name
</programlisting> (Lexical conventions: <computeroutput>token1 | token2</computeroutput> means either <computeroutput>token1</computeroutput> or <computeroutput>token2</computeroutput>; <computeroutput>[token]</computeroutput> means either <computeroutput>token</computeroutput> or nothing; <computeroutput>{expression}</computeroutput> means the token resulting from the expression.)  </entry></row>
</tbody></tgroup></informaltable>
</para><para>The local function name can be qualified by prefixing it with the keyword <computeroutput>inline</computeroutput> (see the  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section): <programlisting language="c++">BOOST_LOCAL_FUNCTION_NAME(inline local_function_name)
</programlisting> This increases the chances that the compiler will be able to inline the local function calls (thus reducing run-time). However, inline local functions cannot be passed as template parameters (e.g., to <computeroutput>std::for_each</computeroutput>) or assigned to other functors (e.g., to <computeroutput>boost::function</computeroutput>). That is true on C++03 compilers but inline local functions can instead be passed as template parameters on C++11 compilers. On C++11 compilers, there is no need to declare a local function lined because this library will automatically use C++11 specific features to inline the local function while always allowing to pass it as a template parameter. This optimization is automatically enabled when the Boost.Config macro <computeroutput>BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS</computeroutput> is not defined but it also be forced using  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS">BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS</macroname></computeroutput>.</para><para>The local function name can also be qualified by prefixing it with the "keyword" <computeroutput>recursive</computeroutput> (see the  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section): <programlisting language="c++">BOOST_LOCAL_FUNCTION_NAME(recursive local_function_name)
</programlisting> This allows the local function to recursively call itself from its body (as usual in C++). However, recursive local functions should only be called within their declaration scope (otherwise the result is undefined behaviour). Finally, compilers have not been observed to be able to inline recursive local function calls, not even when the recursive local function is also declared inline: <programlisting language="c++">BOOST_LOCAL_FUNCTION(inline recursive local_function_name)
</programlisting></para><para><emphasis role="bold">Note:</emphasis> The local function name cannot be the name of an operator <computeroutput>operator...</computeroutput> and it cannot be the same name of another local function declared within the same enclosing scope (but <computeroutput>boost::overloaded_function</computeroutput> can be used to overload local functions, see Boost.Functional/OverloadedFunction and the  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.tutorial"> Tutorial</link> section,  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME_TPL">BOOST_LOCAL_FUNCTION_NAME_TPL</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.local__function_8hpp_1ad3626541dac082571ee18c3a5e4d87b8" name="BOOST_LOCAL_FUNCTION_NAME_TPL" kind="functionlike"><macro-parameter name="name"/><purpose>This macro is used to end a local function declaration specifying its name within templates. </purpose><description><para>This macro must be used instead of  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput> when declaring a local function within a template. A part from that, this macro has the exact same syntax a  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput> (see  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput> for more information): <programlisting language="c++">{ // Some declarative context within a template.
    ...
    result_type BOOST_LOCAL_FUNCTION_TPL(declarations) {
        ... // Body code.
    } BOOST_LOCAL_FUNCTION_NAME_TPL(qualified_name)
    ...
}
</programlisting></para><para>Note that  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput> must be used with this macro instead of  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput>.</para><para><emphasis role="bold">Note:</emphasis> C++03 does not allow to use <computeroutput>typename</computeroutput> outside templates. This library internally manipulates types, these operations require <computeroutput>typename</computeroutput> but only within templates. This macro is used to indicate to the library when the enclosing scope is a template so the library can correctly use <computeroutput>typename</computeroutput>.</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.tutorial"> Tutorial</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput>,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_TPL">BOOST_LOCAL_FUNCTION_TPL</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.local__function_8hpp_1ad75b5a81ff5873c83c5e9d973ef02b9c" name="BOOST_LOCAL_FUNCTION_TYPEOF" kind="functionlike"><macro-parameter name="bound_variable_name"/><purpose>This macro expands to the type of the specified bound variable. </purpose><description><para>This macro can be used within the local functions body to refer to the bound variable types so to declare local variables, check concepts (using Boost.ConceptCheck), etc (see the  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section). This way the local function can be programmed entirely without explicitly specifying the bound variable types thus facilitating maintenance (e.g., if the type of a bound variable changes in the enclosing scope, the local function code does not have to change).</para><para><emphasis role="bold">Parameters:</emphasis> <informaltable><tgroup cols="2"><tbody><row>
<entry><emphasis role="bold"><computeroutput>bound_variable_name</computeroutput></emphasis></entry><entry>The name of one of the local function's bound variables.  </entry></row>
</tbody></tgroup></informaltable>
</para><para>The type returned by the macro is fully qualified in that it contains the extra constant and reference qualifiers when the specified variable is bound by constant and by reference. For example, if a variable named <computeroutput>t</computeroutput> of type <computeroutput>T</computeroutput> is: <itemizedlist>
<listitem><para>Bound by value using <computeroutput>bind t</computeroutput> then <computeroutput><link linkend="doxygen.reference.local__function_8hpp_1ad75b5a81ff5873c83c5e9d973ef02b9c">BOOST_LOCAL_FUNCTION_TYPEOF(t)</link></computeroutput> is <computeroutput>T</computeroutput>. </para>
</listitem>
<listitem><para>Bound by constant value using <computeroutput>const bind t</computeroutput> then <computeroutput><link linkend="doxygen.reference.local__function_8hpp_1ad75b5a81ff5873c83c5e9d973ef02b9c">BOOST_LOCAL_FUNCTION_TYPEOF(t)</link></computeroutput> is <computeroutput>const T</computeroutput>. </para>
</listitem>
<listitem><para>Bound by reference using <computeroutput>bind&amp; t</computeroutput> then <computeroutput><link linkend="doxygen.reference.local__function_8hpp_1ad75b5a81ff5873c83c5e9d973ef02b9c">BOOST_LOCAL_FUNCTION_TYPEOF(t)</link></computeroutput> is <computeroutput>T&amp;</computeroutput>. </para>
</listitem>
<listitem><para>Bound by constant reference using <computeroutput>const bind&amp; t</computeroutput> then <computeroutput><link linkend="doxygen.reference.local__function_8hpp_1ad75b5a81ff5873c83c5e9d973ef02b9c">BOOST_LOCAL_FUNCTION_TYPEOF(t)</link></computeroutput> is <computeroutput>const T&amp;</computeroutput>.</para>
</listitem>
</itemizedlist>
This macro must be prefixed by <computeroutput>typename</computeroutput> when used within templates.</para><para><emphasis role="bold">Note:</emphasis> It is best to use this macro instead of Boost.Typeof so to reduce the number of times Boost.Typeof is used to deduce types (see the  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION">BOOST_LOCAL_FUNCTION</macroname></computeroutput>. </para></description></macro>
</header>
<header id="doxygen.reference.config_8hpp" name="boost/local_function/config.hpp">
<para>Configuration macros allow to change the behaviour of this library at compile-time. </para><macro id="doxygen.reference.config_8hpp_1a45f0a244e9fd84777914e0ed14a0a841" name="BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX"><purpose>Maximum number of parameters supported by local functions. </purpose><description><para>If programmers leave this configuration macro undefined, its default value is <computeroutput>5</computeroutput> (increasing this number might increase compilation time). When defined by programmers, this macro must be a non-negative integer number.</para><para><emphasis role="bold">Note:</emphasis> This macro specifies the maximum number of local function parameters excluding bound variables (which are instead specified by  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX">BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX</macroname></computeroutput>).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.tutorial"> Tutorial</link> section,  <link linkend="boost_localfunction.getting_started"> Getting Started</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX">BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.config_8hpp_1add03ce8a2230ace8d959cc887d0749b7" name="BOOST_LOCAL_FUNCTION_CONFIG_BIND_MAX"><purpose>Maximum number of bound variables supported by local functions. </purpose><description><para>If programmers leave this configuration macro undefined, its default value is <computeroutput>10</computeroutput> (increasing this number might increase compilation time). When defined by programmers, this macro must be a non-negative integer number.</para><para><emphasis role="bold">Note:</emphasis> This macro specifies the maximum number of bound variables excluding local function parameters (which are instead specified by  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX">BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX</macroname></computeroutput>).</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.tutorial"> Tutorial</link> section,  <link linkend="boost_localfunction.getting_started"> Getting Started</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX">BOOST_LOCAL_FUNCTION_CONFIG_ARITY_MAX</macroname></computeroutput>. </para></description></macro>
<macro id="doxygen.reference.config_8hpp_1ad2d293b0c16141cc7fa69e51f5eb979e" name="BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS"><purpose>Specify when local functions can be passed as template parameters without introducing any run-time overhead. </purpose><description><para>If this macro is defined to <computeroutput>1</computeroutput>, this library will assume that the compiler allows to pass local classes as template parameters: <programlisting language="c++">template&lt;typename T&gt; void f(void) {}

int main(void) {
    struct local_class {};
    f&lt;local_class&gt;();
    return 0;
}
</programlisting> This is the case for C++11 compilers and some C++03 compilers (e.g., MSVC), but it is not the case in general for most C++03 compilers (including GCC). This will allow the library to pass local functions as template parameters without introducing any run-time overhead (specifically without preventing the compiler from optimizing local function calls by inlining their assembly code).</para><para>If this macro is defined to <computeroutput>0</computeroutput> instead, this library will introduce a run-time overhead associated to resolving a function pointer call in order to still allow to pass the local functions as template parameters.</para><para>It is recommended to leave this macro undefined. In this case, the library will automatically define this macro to <computeroutput>0</computeroutput> if the Boost.Config macro <computeroutput>BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS</computeroutput> is defined for the specific compiler, and to <computeroutput>1</computeroutput> otherwise.</para><para><emphasis role="bold">See:</emphasis>  <link linkend="boost_localfunction.getting_started"> Getting Started</link> section,  <link linkend="boost_localfunction.advanced_topics"> Advanced Topics</link> section,  <computeroutput><macroname alt="BOOST_LOCAL_FUNCTION_NAME">BOOST_LOCAL_FUNCTION_NAME</macroname></computeroutput>. </para></description></macro>
</header>
</library-reference>